# -*- coding: utf-8 -*-
"""BankAnalyticsCS2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jIMGpu0El3nsFV-VMmKpl4vL-DRxon4l

**Problem Statement: ATM CASH PREDICTION**
"""

#Importing Libraries
import pandas as pd
import numpy as np 
import matplotlib.pyplot as plt 
import seaborn as sns

#!pip3 uninstall statsmodels

!pip3 install numpy scipy patsy pandas

!pip3 install statsmodels

import statsmodels.api as sm

#Loading the dataset 
atm = pd.read_csv('atm bank dataset.csv')
atm

#Knowing the dataset
atm.head()

atm.tail()

print(atm.shape)
print(atm.columns)
print(atm.info)
print(atm.describe().astype(int))
print(atm.dtypes)

#Making New Variables using holiday sequence
previousday_holiday = atm['holiday_sequence'].apply(lambda x: 'W' if x == 'WWW' or x == 'WHW' or x == 'WWH' or x == 'WHH' else 'H') 
print(previousday_holiday)
nextday_holiday = atm['holiday_sequence'].apply(lambda x: 'H' if x == 'HHH' or x == 'WHH' or x == 'WWH' or x == 'HWH' else 'W') 
print(nextday_holiday)

holidays = pd.DataFrame({'previousday_holiday': previousday_holiday,'nextday_holiday': nextday_holiday})
holidays

atm1 = pd.concat([atm,holidays],axis = 1)
atm1

#Dropping the insignifcant columns
atm1 = atm1.drop(atm1.columns[[0,1,5]],axis=1)
atm1

pd.crosstab(atm1['trans_month'],atm1['trans_year'])
#This shows us that we do not per day data i.e daily data in a month

#Checking for missing values
print(atm1.isnull().sum())

"""*Exploratory Data Analysis*"""

sns.barplot(atm1['festival_religion'].value_counts().index,atm1['festival_religion'].value_counts())
plt.xlabel('Festival Religion')
plt.ylabel('Count')
plt.title('Count of Categories of Festival Religion ')

sns.barplot(atm1['working_day'].value_counts().index,atm1['working_day'].value_counts())
plt.xlabel('Working Day')
plt.ylabel('Count')
plt.title('Count of Working day and Holiday ')

sns.barplot(atm1['previousday_holiday'].value_counts().index,atm1['previousday_holiday'].value_counts())
plt.xlabel('Previous Day')
plt.ylabel('Count')
plt.title('Count of Previous Working day or Holiday ')

sns.barplot(atm1['nextday_holiday'].value_counts().index,atm1['nextday_holiday'].value_counts())
plt.xlabel('Next Day')
plt.ylabel('Count')
plt.title('Count of Next Working day or Holiday ')

sns.scatterplot(atm1['prevweek_mean'],atm1['total_amount_withdrawn'],color = 'Red')
plt.xlabel('Previous Week Mean')
plt.ylabel('Total Amount Withdrawn')
plt.title('Total Amount Withdrawn vs Previous Week Mean')
#Here we can see a positive relation Total money withdrawn and Previous week mean

atm1.corr()
#None of the variables show strong correlation

#creating x data 
xdata = range(0,atm1.shape[0])

fig, ax = plt.subplots()
ax.plot(xdata,atm1['prevweek_mean'],label = 'Previous week Mean',color = 'green')

ax.set_title('Line plot for Previous Week Mean')
ax.legend()

#creating x data 
xdata = range(0,atm1.shape[0])

fig, ax = plt.subplots()
ax.plot(xdata,atm1['total_amount_withdrawn'],label = 'Total Amount Withdrawn',color = 'orange')

ax.set_title('Line plot for Total Amount Withdrawn')
ax.legend()

sns.boxplot(data = atm1)
plt.title('Boxplot')
#The boxplot shows presence of outliers

#Finding Outliers 
from scipy import stats 

z = np.abs(stats.zscore(atm1.select_dtypes(include = ['number'])))
print(z)

threshold = 3
print(np.where(z>3))

atm2 = atm1[(z<3).all(axis = 1)]
print(atm2)
print(atm2.shape) #we can see 3 rows have been omitted 
print(atm2.columns)

"""*Creating Dummy Variables*"""

dummy = pd.get_dummies(atm2.select_dtypes(exclude= ['number']),drop_first= True)
dummy

atm3 = atm2.drop(atm2.columns[[0,1,2,8,9]],axis=1)
atm3

atm3 = pd.concat([atm3,dummy],axis = 1)
atm3

corr = atm3.corr()

size = plt.figure(figsize= (12,12))
sns.heatmap(corr,annot= True)

#There isn't strong correlation beytween any of the variables indicating that there is no multicollinearity.

"""*Feature Selection*"""

#Splitting the independent and dependent variables 
x = atm3.drop(columns='total_amount_withdrawn')
y = atm3['total_amount_withdrawn']

import statsmodels.api as sm 

selc = sm.OLS(y,x).fit()
selc.summary()

x = x.drop(columns= 'trans_month')

selc = sm.OLS(y,x).fit()
selc.summary()

x = x.drop(columns= 'festival_religion_NH')

selc = sm.OLS(y,x).fit()
selc.summary()

x = x.drop(columns= 'festival_religion_N')

selc = sm.OLS(y,x).fit()
selc.summary()

x = x.drop(columns= 'weekday_SUNDAY')

selc = sm.OLS(y,x).fit()
selc.summary()

x = x.drop(columns= 'weekday_TUESDAY')

selc = sm.OLS(y,x).fit()
selc.summary()

x = x.drop(columns= 'weekday_THURSDAY')

selc = sm.OLS(y,x).fit()
selc.summary()

x = x.drop(columns= 'festival_religion_M')

selc = sm.OLS(y,x).fit()
selc.summary()

x = x.drop(columns= 'weekday_WEDNESDAY')

selc = sm.OLS(y,x).fit()
selc.summary()

x = x.drop(columns= 'previousday_holiday_W')

selc = sm.OLS(y,x).fit()
selc.summary()

x = x.drop(columns= 'weekday_MONDAY')

selc = sm.OLS(y,x).fit()
selc.summary()
#We have all the variables whose p value is below the level of significance

"""These are the features that we select for our further analysis """

atm4 = pd.concat([x,y],axis = 1)
atm4

"""*Splitting the data into Train and test data*"""

from sklearn.model_selection import train_test_split
xtrain,xtest,ytrain,ytest = train_test_split(x,y,test_size = 0.2, random_state = 0)

"""***Multiple Linear Regression***

*Fitting Multiple Regression Model*
"""

from sklearn.linear_model import  LinearRegression
from sklearn.metrics import mean_absolute_error,mean_squared_error,r2_score
from math import sqrt

regmodel = LinearRegression()
regmodel.fit(xtrain,ytrain)

ypred = regmodel.predict(xtest)

print('R square:', r2_score(ytest,ypred))
mse = mean_squared_error(ytest,ypred)
print('Mean Square Error',mse)
rmse = sqrt(mse)
print('Root mean square error:',rmse)

print('Mean Absolute Error:',mean_absolute_error(ytest,ypred))

"""*Scaling the dataset*"""

from sklearn.preprocessing import StandardScaler
sc_x = StandardScaler()
sc_y = StandardScaler()

xtrain1 = sc_x.fit_transform(xtrain)
xtest1 = sc_x.transform(xtest)

ytrain1 = sc_y.fit_transform(ytrain.values.reshape(-1,1))
ytest1 = sc_y.transform(ytest.values.reshape(-1,1))

"""*Linear Regression on Scaled Data*"""

regmodel1 = LinearRegression()
regmodel1.fit(xtrain1,ytrain1)

ypred1 = regmodel1.predict(xtest1)

print('R square:', r2_score(ytest1,ypred1))
mse = mean_squared_error(ytest1,ypred1)
print('Mean Square Error',mse)
rmse = sqrt(mse)
print('Root mean square error:',rmse)

print('Mean Absolute Error:',mean_absolute_error(ytest1,ypred1))

"""**Polynomial Regression**"""

from sklearn.preprocessing import PolynomialFeatures
from sklearn.pipeline import Pipeline

#Fitting a Polynomial Regression of Degree 2
Input=[('polynomial',PolynomialFeatures(degree=2)),('Linear',LinearRegression())]
pipe=Pipeline(Input)
pipe.fit(xtrain1,ytrain1.reshape(-1,1))
polypred = pipe.predict(xtest1)

print('R square:', r2_score(ytest1,polypred))
mse = mean_squared_error(ytest1,polypred)
print('Mean Square Error',mse)
rmse = sqrt(mse)
print('Root mean square error:',rmse)

print('Mean Absolute Error:',mean_absolute_error(ytest1,polypred))

"""***Random Forest Regression***"""

from sklearn.ensemble import RandomForestRegressor

rfreg = RandomForestRegressor(n_estimators = 100, random_state = 0)
rfreg.fit(xtrain1,ytrain1)

rfpred = rfreg.predict(xtest1)

print('R square:', r2_score(ytest1,rfpred))
mse = mean_squared_error(ytest1,rfpred)
print('Mean Square Error',mse)
rmse = sqrt(mse)
print('Root mean square error:',rmse)

print('Mean Absolute Error:',mean_absolute_error(ytest1,rfpred))

"""![r1.PNG](data:image/png;base64,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)

Since the Root mean square error (RMSE) is less of Polynomial Regression is less than the other models along with high R square we go wit it.

**Time Series**

*Making Time series Data*
"""

tsdata = atm.loc[:,['trans_month','trans_year','total_amount_withdrawn']]
tsdata

tsmean = tsdata.groupby(['trans_year','trans_month']).sum() #Cummulative amunt withdrawn in a month
tsmean = pd.DataFrame(tsmean['total_amount_withdrawn'])
tsmean
tsmean1 = tsmean.values.astype('int')
tsmean1
tsmean1 = pd.DataFrame(tsmean1)
tsmean1

idx = pd.Series(pd.period_range('20110101', freq='M', periods=81))
idx

dates = pd.to_datetime(idx.astype(str))
dates
dates = pd.DataFrame(dates)
dates

tsdata1 = pd.concat([dates,tsmean1],axis = 1)
tsdata1.columns = ['date','total_amount_withdrawn']
tsdata1

plt.plot(tsdata1['date'],tsdata1['total_amount_withdrawn'])
plt.xlabel('Time')
plt.ylabel('Total Amount Withdrawn')
plt.title('Total Amount Withdrawn Month-Wise ')

"""Here we can see that one point changes falls below the range of the other data points and hence can be said as an outlier."""

tsdata1[70:]

tsdata1.iloc[70,1]

"""Here we see that the total amount witrhdrawn for the month of December 2016 is far less than all the other values. Therefore we eliminate that value and impute it with the mean of of it's consecutive datapoints. """

from statistics import mean
a = tsdata1.iloc[70,1]
b = tsdata1.iloc[72,1]
tsdata1.iloc[71,1] = mean([a,b])

tsdata1[70:]

plt.plot(tsdata1['date'],tsdata1['total_amount_withdrawn'])
plt.xlabel('Time')
plt.ylabel('Total Amount Withdrawn')
plt.title('Total Amount Withdrawn Month-Wise ')

tsdata2 = tsdata1.set_index('date')
tsdata2

"""*Durbin Watson Test to Check AutoCorrelation*

A test statistic of 2 indicates no serial correlation.
The closer the test statistics is to 0, the more evidence of positive serial correlation.
The closer the test statistics is to 4, the more evidence of negative serial correlation.
"""

#Durbin Watson Test to Check Autocorrelation
from statsmodels.stats.stattools import durbin_watson
taw = tsdata2['total_amount_withdrawn'].values
durbin_watson(taw)
#Since the test statistic is closer to 0,it means that there is some positive autocorrelation

"""*Looking for Trend and Seasonality in the data*"""

from statsmodels.tsa.seasonal import seasonal_decompose
dec = seasonal_decompose(tsdata2,model = 'additive')
dec.plot()
plt.show()

#This shows us that we have a trend and seasonality present in our data

"""*Checking for Stationarity using ADF Test*"""

#Checking whether the data is Stationary using ADF test
from statsmodels.tsa.stattools import adfuller
print ('Results of Dickey-Fuller Test:')
dftest = adfuller(tsdata1['total_amount_withdrawn'].values, autolag= 'AIC')
dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])
for key,value in dftest[4].items():
   dfoutput['Critical Value (%s)'%key] = value
print (dfoutput)

"""Since the pvalue is greater than 0.05 we fail to reject Ho and conclude that the series is non stationary.

*Splitting the data into Training and Test data*
"""

tsdata_train = tsdata2.iloc[0:72] #Considering all the data till 2016 as train data 
print(tsdata_train)
tsdata_test = tsdata2.iloc[72:] #Considerng all the 2017 data as test data
print(tsdata_test)

"""*Making the Data Stationary*"""

#Transforming the data to reduce the trend 
ts_log = np.log(tsdata_train)
plt.plot(ts_log)

dec = seasonal_decompose(ts_log,model = 'additive')
dec.plot()
plt.show()
#We can see that the trend has been smoothened a bit

#Differencing the data 
tslog_diff = ts_log - ts_log.shift(1)
tslog_diff
plt.plot(tslog_diff)

tslog_diff = tslog_diff.dropna(axis = 0)
tslog_diff

#Checking whether the data is Stationary using ADF test
print ('Results of Dickey-Fuller Test:')
dftest = adfuller(tslog_diff['total_amount_withdrawn'].values, autolag= 'AIC')
dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])
for key,value in dftest[4].items():
   dfoutput['Critical Value (%s)'%key] = value
print (dfoutput)

"""Since the pvalue is less than 0.05 we reject Ho and conclude that the series is stationary."""

dec = seasonal_decompose(tslog_diff,model = 'additive')
dec.plot()
plt.show()

"""*Making ACF And PACF plots*"""

#ACF and PACF plots
from statsmodels.graphics.tsaplots import plot_acf,plot_pacf

plot_acf(tslog_diff)
plot_pacf(tslog_diff)
plt.show()

"""*Fitting Arima Model*"""

from statsmodels.tsa.arima_model import ARIMA

!pip3 install pmdarima

from pmdarima.arima import auto_arima

model = auto_arima(tsdata_train,stepwise= True,stationary= True)
model.fit(tsdata_train)
model.summary()

stepwise_model = auto_arima(tsdata_train,seasonal=True, trace=True,m = 12,
                           error_action='ignore', stationary = True,
                           suppress_warnings=True, 
                           stepwise=True)

"""Here we can see we get ARIMA(1,0,0)(0,0,0)[12] , SARIMA(1,0,0) with the least AIC value."""

forecast = model.predict(n_periods= len(tsdata_test))
forecast
forecast = forecast.astype('int')
print(forecast)
forecast = pd.DataFrame(forecast,index = tsdata_test.index,columns=['Prediction'])
forecast

#plot the predictions for validation set
plt.plot(tsdata_train, label='Train')
plt.plot(tsdata_test, label='Test')
plt.plot(forecast, label='Prediction')
plt.show()

"""*Evaluating the model*"""

#Calculating RMSE
from math  import sqrt 
from sklearn.metrics import mean_squared_error

mse = mean_squared_error(tsdata_test,forecast)
print('Mean Square Error',mse)
rmse = sqrt(mse)
print('Root mean square error:',rmse)

print('Mean Absolute Error:',mean_absolute_error(tsdata_test,forecast))